{
    "collab_server" : "",
    "contents" : "myBarPlot <- function(dat,\n                      xVal,\n                      yVal,\n                      fillVal=\"Stage\",\n                      ylabel,\n                      xlabel=NULL,\n                      ymax=1,\n                      abline=FALSE,\n                      ablinePos=NULL,\n                      logy=FALSE,\n                      axs.txt.y=8,\n                      discrete.y=FALSE)\n{\n    a <- ggplot(dat,aes_string(x=xVal,y=yVal,fill=fillVal))+ylim(0,ymax)\n    if(logy) a <- a+scale_y_log10()\n    if(discrete.y) a <- a+scale_y_continuous(breaks=pretty_breaks())\n\n    a <- a+geom_bar(stat=\"identity\", position=\"dodge\")\n    a <- a+ylab(ylabel)+labs(fill = \"Condition\")\n\n    if (!is.null(xlabel))\n        {\n            print(xlabel)\n            a <- a+xlab(xlabel)\n        }\n\n    a <- a+theme(panel.grid.minor=element_blank(),\n                 panel.grid.major=element_blank(),\n                 legend.background = element_rect(colour = \"black\"),\n                 axis.ticks.x=element_blank(),\n                 axis.text.x = element_text(size=6,angle=90, vjust=.5),\n                 axis.text.y = element_text(size=axs.txt.y),\n                 axis.title.y=element_text(size=10),\n                 axis.title.x=element_text(size=10))\n\n    ## Print a set of horizontal cut off lines\n    if (abline)\n        {\n            for (i in  1: length(ablinePos))\n                {\n                    val <- ablinePos[i]\n                    a <- a+geom_hline(aes_string(yintercept=val))\n                }\n        }\n    print(a)\n}\n## Multiple plot function\n\n## ggplot objects can be passed in ..., or to plotlist (as a list of ggplot objects)\n## - cols:   Number of columns in layout\n## - layout: A matrix specifying the layout. If present, 'cols' is ignored.\n\n## If the layout is something like matrix(c(1,2,3,3), nrow=2, byrow=TRUE),\n## then plot 1 will go in the upper left, 2 will go in the upper right, and\n## 3 will go all the way across the bottom.\n\nmultiplot <- function(...,\n                      plotlist=NULL,\n                      file,\n                      cols=1,\n                      layout=NULL)\n    {\n        require(grid)\n\n                                        # Make a list from the ... arguments and plotlist\n        plots <- c(list(...), plotlist)\n\n        numPlots = length(plots)\n\n                                        # If layout is NULL, then use 'cols' to determine layout\n        if (is.null(layout))\n            {\n                                        # Make the panel\n                                        # ncol: Number of columns of plots\n                                        # nrow: Number of rows needed, calculated from # of cols\n                layout <- matrix(seq(1, cols * ceiling(numPlots/cols)),\n                                 ncol = cols, nrow = ceiling(numPlots/cols))\n            }\n\n        if (numPlots==1)\n            {\n                print(plots[[1]])\n\n            }\n        else\n            {\n                                        # Set up the page\n                grid.newpage()\n                pushViewport(viewport(layout = grid.layout(nrow(layout), ncol(layout))))\n\n                                        # Make each plot, in the correct location\n                for (i in 1:numPlots)\n                    {\n                                        # Get the i,j matrix positions of the regions that contain this subplot\n                        matchidx <- as.data.frame(which(layout == i, arr.ind = TRUE))\n\n                        print(plots[[i]], vp = viewport(layout.pos.row = matchidx$row,\n                                              layout.pos.col = matchidx$col))\n                    }\n            }\n    }\n\n\ncreateAnalysisData<-function(inFile)\n{\n                                        ##inFile= \"cortexGeneCounts_sense.sum.cnts.csv\"\n                                        ##inFile = \"cerebGeneCounts_sense.sum.cnts.csv\"\n    inputDat<-read.csv(file = inFile, header=T)\n    zerosToRm <- zeroPositions(inputDat[,-c(1:3)])\n    inputDat <- inputDat[zerosToRm,]\n    inputDatLong <-melt(inputDat,id.vars=c(\"gene\",\"chr\",\"start\",\"end\"))\n    names(inputDatLong)[5] <- \"SampleID\"\n    print (\"Converting data to Long Format\")\n    print(head(inputDatLong))\n    libSizes <- aggregate(value~SampleID,data=inputDatLong,sum)\n    names(libSizes)[2]<-\"libSize\"\n    print (\"\\nCalculating Library Sizes\")\n    print(head(libSizes))\n    inputDatLong<-merge(inputDatLong, libSizes, by=\"SampleID\")\n    inputDatLong$cpm <- inputDatLong$value*1000000/inputDatLong$libSize\n    results <- list(long=inputDatLong, wide=inputDat)\n    return(results)\n}\n\ncreateAnalysisDataFromDb<-function(inDat)\n{\n    library(reshape2)\n    tmpDat.wide <- dcast(inDat,geneId~id,value.var=\"expression\")\n    tmpDat.1 <- subset(inDat, select=c(\"geneId\",\"location\"))\n    tmpDat.1 <- tmpDat.1[!duplicated(tmpDat.1[,\"geneId\"]),]\n    tmpDat.wide <- merge(tmpDat.1,tmpDat.wide, by=\"geneId\")\n    tmpDat.wide.chr  <- colsplit(tmpDat.wide$location, \":\" , names = c(\"chr\",\"position\"))\n    tmpDat.wide.pos <- colsplit(tmpDat.wide.chr$position, \"-\", names=c(\"start\",\"end\"))\n    tmpDat.wide <- tmpDat.wide[,-c(2)]\n    tmpDat.wide <- cbind(tmpDat.wide.chr[,1], tmpDat.wide.pos[,1],tmpDat.wide.pos[,2],tmpDat.wide)\n    names(tmpDat.wide)[1:4] <- c(\"chr\",\"start\",\"end\",\"gene\")\n\n    print (\"\\nOriginal data\\n\")\n    print(head(tmpDat.wide))\n\n    print (\"\\nDimensions of Original data\\n\")\n    print(dim(tmpDat.wide))\n    print(\"\\n\\n\")\n    inputDat <- tmpDat.wide\n    rm(tmpDat.wide)\n    zerosToRm <- zeroPositions(inputDat[,-c(1:3)])\n    inputDat <- inputDat[zerosToRm,]\n    inputDatLong <-melt(inputDat,id.vars=c(\"gene\",\"chr\",\"start\",\"end\"))\n    names(inputDatLong)[5] <- \"SampleID\"\n\n    print (\"\\nConverting data to Long Format\\n\")\n    print(head(inputDatLong))\n    libSizes <- aggregate(value~SampleID,data=inputDatLong,sum)\n    names(libSizes)[2]<-\"libSize\"\n\n    print (\"\\nCalculating Library Sizes\\n\")\n    print(head(libSizes))\n    inputDatLong<-merge(inputDatLong, libSizes, by=\"SampleID\")\n    inputDatLong$cpm <- inputDatLong$value*1000000/inputDatLong$libSize\n    results <- list(long=inputDatLong, wide=inputDat)\n    return(results)\n}\n\n\n\ncreateAnalysisData16p<-function(inFile)\n{\n  #inFile= \"cortexGeneCounts_sense.sum.cnts.csv\"\n  #inFile = \"cerebGeneCounts_sense.sum.cnts.csv\"\n  inputDat<-read.csv(inFile, header=T)\n  zerosToRm <- zeroPositions(inputDat[,-c(1:3)])\n  inputDat <- inputDat[zerosToRm,]\n  inputDatLong <-melt(inputDat,id.vars=c(\"gene\",\"chr\",\"start\",\"end\"))\n  names(inputDatLong)[5] <- \"SampleID\"\n  print(head(inputDatLong))\n  idCols<-colsplit(inputDatLong$SampleID, \"_\", names=c(\"Animal_ID\",\"Tissue\"))\n  inputDatLong$AnimalID <- idCols$Animal_ID\n  inputDatLong$Tissue <- idCols$Tissue\n  print(head(inputDatLong))\n  libSizes <- aggregate(value~SampleID,data=inputDatLong,sum)\n  names(libSizes)[2]<-\"libSize\"\n  print(head(libSizes))\n  inputDatLong<-merge(inputDatLong, libSizes, by=\"SampleID\")\n  inputDatLong$cpm <- inputDatLong$value*1000000/inputDatLong$libSize\n  results <- list(long=inputDatLong, wide=inputDat)\n  return(results)\n}\n\n## Function to remove rows with zeros across all samples\nzeroPositions <- function(inDat)\n{\n  row_sub <- apply(inDat[-c(1)], 1, function(row)\n      {\n          y <- TRUE\n          if(all(row ==0 ))\n              {y <- FALSE}\n          return(y)\n      })\n  print (paste(\"Number of Non zero rows:\",sum(row_sub)))\n  print (paste(\"Number of rows with zeros:\",dim(inDat)[1]-sum(row_sub)))\n  return(row_sub)\n}\n\n## Function to return the positions from a wide data where all samples have\n## expression values greater than a given input threshold\n\nthreshPositions <- function(inDat, threshold)\n    {\n        row_sub <- apply(inDat[-c(1)], 1, function(row)\n            {\n                y <- TRUE\n                if(any(row < threshold ))\n                    {y <- FALSE}\n                return(y)\n            })\n        print (paste(\"Number of rows passing Threshold:\",sum(row_sub)))\n        print (paste(\"Number of rows under Threshold:\",dim(inDat)[1]-sum(row_sub)))\n        return(list(rows=row_sub, genes=inDat$gene[row_sub]))\n  }\n\n\n## Function to recreate dataset from bedtools counts data given genes to remove\n\nfilterGenes <- function(inputDat,genelist)\n{\n    rmPos <- which(as.character(genelist) %in% as.character(inputDat$gene))\n    genesToRm <- genelist[rmPos]\n    rmPos2 <- which(as.character(inputDat$gene) %in% as.character(genesToRm))\n    inputDat.rm <-inputDat[-c(rmPos2),]\n    inputDatLong <- melt(inputDat.rm,id.vars=c(\"gene\",\"chr\",\"start\",\"end\"))\n    names(inputDatLong)[5] <- \"SampleID\"\n    print(head(inputDatLong))\n    print(head(inputDatLong))\n    libSizes <- aggregate(value~SampleID,data=inputDatLong,sum)\n    names(libSizes)[2]<-\"libSize\"\n    print(head(libSizes))\n    inputDatLong<-merge(inputDatLong, libSizes, by=\"SampleID\")\n    inputDatLong$cpm <- inputDatLong$value*1000000/inputDatLong$libSize\n    results <- list(long=inputDatLong, wide=inputDat.rm)\n    return(results)\n}\n\n\n\n## Function to recreate dataset given genes to remove\n\nfilterGenes16p <- function(inputDat,genelist)\n{\n    rmPos <- which(as.character(genelist) %in% as.character(inputDat$gene))\n    genesToRm <- genelist[rmPos]\n    rmPos2 <- which(as.character(inputDat$gene) %in% as.character(genesToRm))\n    inputDat.rm <- inputDat[-c(rmPos2),]\n    inputDatLong <- melt(inputDat.rm,id.vars=c(\"gene\",\"chr\",\"start\",\"end\"))\n    names(inputDatLong)[5] <- \"SampleID\"\n    print(head(inputDatLong))\n    idCols <- colsplit(inputDatLong$SampleID, \"_\", names=c(\"Animal_ID\",\"Tissue\"))\n    inputDatLong$AnimalID <- idCols$Animal_ID\n    inputDatLong$Tissue <- idCols$Tissue\n    print(head(inputDatLong))\n    libSizes <- aggregate(value~SampleID,data=inputDatLong,sum)\n    names(libSizes)[2]<-\"libSize\"\n    print(head(libSizes))\n    inputDatLong <- merge(inputDatLong, libSizes, by=\"SampleID\")\n    inputDatLong$cpm <- inputDatLong$value*1000000/inputDatLong$libSize\n    results <- list(long=inputDatLong, wide=inputDat.rm)\n    return(results)\n}\n\n\n## MDSPlots using ggplot2\nggMDSplot <- function(wideDat, cols=c(1,2), modMat=mod.Matrix, modCol=3, txtSize=1, sampleLoc=\"newSampId\")\n{\n    ## wideDat <- geneDat.wide.rmZ\n    ## modMat <- mod.Matrix\n    ##cols <- c(1,2)\n    ## modCol <- 4\n    ##wideDat <- tmpDat.cpm\n    ##modMat <- mod.matrix.cere\n    ##cols <- c(1,2)\n    ##modCol <- 7\n    ##sampleLoc <- \"SampleID\"\n    d <- dist(t(wideDat[,-c(1)]))\n\n    mds.fit <- cmdscale(d, eig = TRUE, k = 2)\n\n    mds.d <- data.frame(x1 = mds.fit$points[, cols[1]], x2 = mds.fit$points[, cols[2]],\n                        samples = colnames(wideDat[,-c(1)]))\n    mds.d$treatment <- as.factor(modMat[match(as.character(mds.d$samples),as.character(modMat[,sampleLoc])),modCol])\n\n    g1 <- ggplot(mds.d) + geom_text(aes(x = x1, y = x2, label =samples , colour = treatment), size=txtSize)\n    return(g1)\n}\n\n## qqplots using ggplot2\nqqGGplot <- function(pvector, colsToUse =NULL)\n{\n    ##pvector <- lmContr$contr.KV.WV$results$pval\n    o <- -log10(sort(pvector,decreasing=F))\n    e <- -log10( 1:length(o)/length(o) )\n    maxAxis <- -log10(min(pvector[which(pvector > 0)],pvector[which(pvector > 0)]))+1.5\n    pdat <-data.frame(list(obs=o,theo=e))\n    p1 <- ggplot(pdat,aes(x=theo,y=obs))\n    if(is.null(colsToUse)){ p1 <- p1+geom_point()+xlim(c(0,maxAxis))}\n    else { p1 <- p1+geom_point(col=colsToUse)+xlim(c(0,maxAxis))}\n    p1 <- p1+ylim(c(0,maxAxis))+geom_abline(intercept=0,slope=1, col=\"red\")\n    p1 <- p1+xlab(\"-log10(Expected)\")+ylab(\"-log10(Observed)\")\n    return(p1)\n}\n\n## Create a new sample column based on adding an additional factor\nnewDat <- function(inDat,\n                   inlevel=\"ctx\",\n                   colName=\"Tissue\",\n                   sampleCol=\"AnimalID\",\n                   outCol=\"SampleID\")\n{\n    inDat[,colName] <- inlevel\n    inDat[,outCol] <- paste(as.character(inDat[,sampleCol]),inDat[, colName], sep=\"_\")\n    return(inDat)\n}\n\n## Pairs plots\npanel.cor.scale <- function(x,\n                            y,\n                            digits=2,\n                            prefix=\"\",\n                            cex.cor)\n{\n    usr <- par(\"usr\"); on.exit(par(usr))\n    par(usr = c(0, 1, 0, 1))\n    r = (cor(x, y,use=\"pairwise\"))\n    txt <- format(c(r, 0.123456789), digits=digits)[1]\n    txt <- paste(prefix, txt, sep=\"\")\n    if(missing(cex.cor)) cex <- 0.8/strwidth(txt)\n    text(0.5, 0.5, txt, cex = cex * abs(r))\n}\n\n\npanel.cor <- function(x, y, digits=2, prefix=\"\", cex.cor)\n{\n    usr <- par(\"usr\"); on.exit(par(usr))\n    par(usr = c(0, 1, 0, 1))\n    r = (cor(x, y,use=\"pairwise\"))\n    txt <- format(c(r, 0.123456789), digits=digits)[1]\n    txt <- paste(prefix, txt, sep=\"\")\n    if(missing(cex.cor)) cex <- 0.8/strwidth(txt)\n    text(0.5, 0.5, txt, cex = cex )\n}\n\n\npanel.hist <- function(x, ...)\n{\n    usr <- par(\"usr\"); on.exit(par(usr))\n    par(usr = c(usr[1:2], 0, 1.5) )\n    h <- hist(x, plot = FALSE)\n    breaks <- h$breaks; nB <- length(breaks)\n    y <- h$counts; y <- y/max(y)\n    rect(breaks[-nB], 0, breaks[-1], y, col=\"cyan\", ...)\n}\n\n\npairs.panels <- function (x,y,smooth=TRUE,scale=FALSE)\n{\n    par(pch =\".\" )\n    if (smooth )\n        {\n            if (scale)\n                {\n                    pairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale,lower.panel=panel.smooth)\n                }\n            else{\n                pairs(x,diag.panel=panel.hist,upper.panel=panel.cor,lower.panel=panel.smooth)\n            } #else {pairs(x,diag.panel=panel.hist,upper.panel=panel.cor,lower.panel=panel.smooth)\n        }\n    else #smooth is not true\n        {\n            if (scale)\n                {\n                    pairs(x,diag.panel=panel.hist,upper.panel=panel.cor.scale)\n                }\n            else\n                {\n                    pairs(x,diag.panel=panel.hist,upper.panel=panel.cor)\n                }\n        } #end of else (smooth)\n} #end of function\n\n## Get Gene list from threshold\ngenesToKeep <- function(inDat, threshold)\n{\n                                        #inDat <- cortexDatFilt1\n                                        #threshold <- 12\n    inDat <- dcast(gene~SampleID,data = inDat, value.var=\"value\")\n    rowsToKeep <- apply(inDat[,-c(1)],MARGIN = 1, FUN =function(x, t) { y <- TRUE ;  if(any(x < t)){ y <- FALSE}; return (y)}, t= threshold)\n    genesKept<- as.character(inDat$gene[rowsToKeep])\n    return(genesKept)\n                                        #rm(inDat)\n                                        #rm(threshold)\n                                        #rm(rowsToKeep)\n                                        #rm(genesKept)\n}\n\n### Get alignmentStats data\n## column order\n## 1  SummStats:Sample\n## 3\tFR\n## 22\tRF\n## 10\tFF\n## 18\tRR\n## 21\tnumAlignments\n## 13\tnumUniqAlign\n## 35\tnumUniqAlignPE\n## 7\tnumUniqAlignPEProper\n## 25\tnumUniqAlignPEProperFR\n## 6\tnumUniqAlignPEProperFF\n## 33\tnumUniqAlignPEProperRR\n## 9\tnumUniqAlignPELong\n## 30\tnumUniqAlignPELongConc\n## 8\tnumUniqAlignPELongConcFR\n## 17\tnumUniqAlignPELongConcFF\n## 36\tnumUniqAlignPELongConcRR\n## 23\tnumUniqAlignPELongDisc\n## 34\tnumUniqAlignPELongDiscFR\n## 28\tnumUniqAlignPELongDiscFF\n## 20\tnumUniqAlignPELongDiscRR\n## 44\tnumMultipleAlign\n## 39\tnumMultipleAlignPE\n## 2\tnumMultipleAlignPEProper\n## 38\tnumMultipleAlignPEProperFR\n## 42\tnumMultipleAlignPEProperFF\n## 5\tnumMultipleAlignPEProperRR\n## 24\tnumMultipleAlignPELong\n## 37\tnumMultipleAlignPELongConc\n## 40\tnumMultipleAlignPELongConcFR\n## 45\tnumMultipleAlignPELongConcFF\n## 19\tnumMultipleAlignPELongConcRR\n## 43\tnumMultipleAlignPELongDisc\n## 4\tnumMultipleAlignPELongDiscFR\n## 11\tnumMultipleAlignPELongDiscFF\n## 26\tnumMultipleAlignPELongDiscRR\n## 16\tnumUniqAlignSE\n## 29\tnumUnmapped\n## 15\tnumMultipleAlignSE\n## 27\tnumERCCUniqAlignPE\n## 12\tnumERCCUniqAlignDisc\n## 14\tnumERCCUniqAlignPEDisc\n## 41\tnumERCCMultipleAlignPE\n## 31\tnumERCCMultipleAlignDisc\n## 32\tnumERCCMultipleAlignPEDisc\n\ngetAlignStats <-function(infile)\n{\n\n  dat<- read.csv(infile, header=T)\n  dat <- dat [, c(1,3,22,10,18,21,13,35,7,25,6,33,9,30,8,17,36,23,34,28,20,44,39,2,38,42,5,24,37,40,45,19,43,4,11,26,16,29,15,27,12,14,41,31,32)]\n  names(dat)[1] <- \"SampleID\"\n  return(dat)\n}\n\n\n## Draw CPM Plots by Genotype\nplotbyGtype <- function( inDat, plotFile=\"plots/7qRegionMeans.png\")\n{\n                                        #inDat <- ctxDat7q.Batch2\n                                        #plotFile <- \"plots/7qRegionMeansBatch2_%d.png\"\n    length(unique(inDat$gene))\n    print(unique(inDat$gene))\n    head(inDat)\n    gtypeMeans <- aggregate(cpm~gene:Gtype, data=inDat, mean)\n    geneInfo <- inDat[,c(\"gene\",\"chr\",\"start\",\"end\")]\n    geneInfo <- geneInfo[!duplicated(geneInfo),]\n    gtypeMeans <- merge(gtypeMeans,geneInfo , by=\"gene\")\n    gtypeMeans <- gtypeMeans[order(gtypeMeans$start,gtypeMeans$Gtype),]\n    head(gtypeMeans)\n\n    gtypeNorm <- subset(gtypeMeans, Gtype==\"WT\")\n    gtypeNorm <- gtypeNorm [ ,c(\"gene\",\"cpm\")]\n    names(gtypeNorm)[2] <- \"wtcpm\"\n    print(head(gtypeNorm))\n\n    gtypeMeans <- merge(gtypeMeans, gtypeNorm, by=\"gene\")\n    gtypeMeans$log2FC <- log2(gtypeMeans$cpm/gtypeMeans$wtcpm)\n    gtypeMeans$FC <- gtypeMeans$cpm/gtypeMeans$wtcpm\n    geneNames <- read.csv(\"genesToNames.csv\",header=T)\n    head(geneNames)\n    gtypeMeans <- merge(gtypeMeans,geneNames, by=\"gene\")\n\n    print(plotFile)\n\n    png(file= plotFile ,height =8, width= 12, res = 600,units =\"in\" )\n    g1 <- ggplot(gtypeMeans,aes(x=as.factor(start/1000),y=log(cpm), colour=Gtype))\n    print(g1+geom_point()+theme(axis.text.x=element_text(angle=90)))\n\n    g1 <- ggplot(gtypeMeans,aes(x=as.factor(start/1000),y=log2FC, colour=Gtype))\n    print(g1+geom_point()+theme(axis.text.x=element_text(angle=90)))\n\n    g1 <- ggplot(gtypeMeans,aes(x=as.factor(start/1000),y=FC, colour=Gtype))\n    print(g1+geom_point()+theme(axis.text.x=element_text(angle=90)))\n    dev.off()\n}\n\n\n## Read Alignment Stat datq\nreadAlignStats <-function(alignFile,nSamp,locDup,locGpRna)\n{\n    ##alignFile <-\"fdmouseSummaries.txt\"\n    ##locDup <- 125\n    ##locGpRna <- 218\n    ##nSamp <- 30\n    dupStat<- read.csv(alignFile,skip=locDup-1, header=T,nrows=nSamp)\n    names(dupStat) <- c(\"Sample\",\"UNMAPPED_READS\" ,\"ESTIMATED_LIBRARY_SIZE\",\"OPTICAL_DUPS\",\"readPairs\",\n                        \"UNPAIRED_READS\", \"DUP_percent\",\"LIBRARY\",\"READ_PAIR_DUPS\",\n                        \"UNPAIRED_DUPS\")\n    gpRnaSeqQc <-read.csv(alignFile,skip=locGpRna-1, header=T,nrows=nSamp)\n\n    names(gpRnaSeqQc) <-c(\"SampleID\",\"Total_Reads_Mapped\",\"rRNA\",\"Mapped_Reads\", \"Unique_Mapping_Rate\",\n                          \"Intragenic_Rate\",\"Note\",\"Mapped_Unique\",\"Intergenic_Rate\",\n                          \"End1_Sense\", \"Genes_Detected\",\"Num_Gaps\",\"Mean_CV\",\n                          \"End1_Mapping_Rate\",\"End2_Mapping_Rate\",\"Mapped_Pairs\",\"End1_Mismatch_Rate\",\n                          \"Estimated_Library_Size\",\"X5__Norm\",\"Failed_Vendor_QC_Check\",\"End2_Sense\",\n                          \"Mapping_Rate\", \"Fragment_Length_Mean\",\"Duplication_Rate_of_Mapped\",\n                          \"rRNA_rate\",\"Intronic_Rate\",\"Read_Length\", \"Transcripts_Detected\",\n                          \"End1_Antisense\",\"Gap_Pct\",\"Expression_Profiling_Efficiency\",\"End1_Pct_Sense\",\n                          \"Unpaired_Reads\",\"Cumul_Pct_Gap_Length\",\"No_Pct_Covered_5Prime\",\n                          \"Alternative_Alignments\",\"Chimeric_Pairs\",\"End2_Mismatch_Rate\",\n                          \"Fragment_Length_StdDev\",\n                          \"Mapped_Unique_Rate_of_Total\",\"Exonic_Rate\",\n                          \"End2_Pct_Sense\",\"Sample\",  \"Base_Mismatch_Rate\",\"End2_Antisense\",\n                          \"Mean_Per_Base_Cov\")\n\n    return(list(dupMetrics=dupStat, gpRnaSeqQc=gpRnaSeqQc))\n}\n\n## Read Alignment Stat datq\nreadGpRNAStats <-function(alignFile)\n  {\n      gpRnaSeqQc <-read.csv(alignFile,header=T)\n\n      names(gpRnaSeqQc) <-c(\"SampleID\",\"Total_Reads_Mapped\",\"rRNA\",\"Mapped_Reads\", \"Unique_Mapping_Rate\",\n                            \"Intragenic_Rate\",\"Note\",\"Mapped_Unique\",\"Intergenic_Rate\",\n                            \"End1_Sense\", \"Genes_Detected\",\"Num_Gaps\",\"Mean_CV\",\n                            \"End1_Mapping_Rate\",\"End2_Mapping_Rate\",\"Mapped_Pairs\",\"End1_Mismatch_Rate\",\n                            \"Estimated_Library_Size\",\"X5__Norm\",\"Failed_Vendor_QC_Check\",\"End2_Sense\",\n                            \"Mapping_Rate\", \"Fragment_Length_Mean\",\"Duplication_Rate_of_Mapped\",\n                            \"rRNA_rate\",\"Intronic_Rate\",\"Read_Length\", \"Transcripts_Detected\",\n                            \"End1_Antisense\",\"Gap_Pct\",\"Expression_Profiling_Efficiency\",\"End1_Pct_Sense\",\n                            \"Unpaired_Reads\",\"Cumul_Pct_Gap_Length\",\"No_Pct_Covered_5Prime\",\n                            \"Alternative_Alignments\",\"Chimeric_Pairs\",\"End2_Mismatch_Rate\",\n                            \"Fragment_Length_StdDev\",\n                            \"Mapped_Unique_Rate_of_Total\",\"Exonic_Rate\",\n                            \"End2_Pct_Sense\",\"Sample\",  \"Base_Mismatch_Rate\",\"End2_Antisense\",\n                            \"Mean_Per_Base_Cov\")\n\n      return(gpRnaSeqQc)\n  }\n## Gp Rna Setup\nsetupGpRnaSeq <- function(inDat)\n{\n    inDat$Mapping_Rate_of_Total <- inDat$Mapped_Reads/(inDat$FastqReads*2)\n    inDat$Mapped_Unique_Rate_of_Total <- inDat$Mapped_Unique/(2*inDat$FastqReads)\n    inDat$Chimeric_Rate <- inDat$Chimeric_Pairs/inDat$Mapped_Pairs\n\n    mappingCols <- c(\"SampleID\", \"FastqReads\",\"Total_Reads_Mapped\",\"Mapped_Reads\", \"Mapped_Unique\", \"Mapped_Pairs\",\"Chimeric_Pairs\")\n\n    otherMappingCols <-c(\"SampleID\", \"Alternative_Alignments\", \"Unpaired_Reads\", \"End1_Sense\", \"End2_Sense\", \"End1_Antisense\",  \"End2_Antisense\")\n\n    rateCols <- c(\"SampleID\", \"Mapping_Rate_of_Total\", \"Mapping_Rate\", \"Mapped_Unique_Rate_of_Total\",  \"Unique_Mapping_Rate\",\"Chimeric_Rate\")\n    otherRateCols <-c( \"SampleID\", \"End1_Mapping_Rate\", \"End2_Mapping_Rate\", \"Base_Mismatch_Rate\",\n                      \"End1_Mismatch_Rate\", \"End2_Mismatch_Rate\", \"End1_Pct_Sense\", \"End2_Pct_Sense\")\n\n\n    otherStatsCols <- c(\"SampleID\",\"Duplication_Rate_of_Mapped\",\"Mean_Per_Base_Cov\",\"Estimated_Library_Size\",\n                        \"Fragment_Length_Mean\",\"Fragment_Length_StdDev\",\"Genes_Detected\", \"Transcripts_Detected\")\n\n    geneStatsCols<-c(\"SampleID\", \"Intragenic_Rate\",\"Exonic_Rate\",\t\"Intronic_Rate\",\"Intergenic_Rate\",\t\"Expression_Profiling_Efficiency\")\n    return(list(data=inDat,mappingCols=mappingCols,otherMappingCols=otherMappingCols,rateCols=rateCols,otherRateCols=otherRateCols,\n                otherStatCols=otherStatsCols,geneStatsCols=geneStatsCols))\n\n}\n\n## MySQL functions\n\nuploadCountsToMySQLDB <- function(inCountsFile, strand=\"sense\", type=\"counts\", mapping=\"multiple\",tool=\"bedtools\",desc=\"NULL\" )\n{\n    library(reshape2)\n    library(RMySQL)\n                                        #inCountsFile <- \"/Users/ashok/Documents/Research/CHGR/16pMusTissueSpecific/DataAnalysis/Counts/bfatGeneCounts_sense.sum.cnts.csv\"\n                                        #type <-\"counts\"\n                                        #strand <- \"sense\"\n                                        #mapping <- \"multiple\"\n                                        #tool <- \"bedtools\"\n                                        #desc <- \"NULL\"\n    counts_dat <- read.csv(inCountsFile, header=T)\n    counts_dat_long <- melt(counts_dat,value.name = \"counts\",id.vars = c(\"gene\",\"chr\",\"start\",\"end\"))\n    counts_dat_long$location=paste(counts_dat_long$chr, paste(counts_dat_long$start,counts_dat_long$end, sep=\"-\"), sep=\":\")\n    counts_dat_long <- subset(counts_dat_long, select=c(\"gene\",\"variable\",\"counts\",\"location\"))\n    names(counts_dat_long) <-c(\"geneid\",\"id\",\"expression\",\"location\")\n    counts_dat_long$type<-type\n    counts_dat_long$strand <- strand\n    counts_dat_long$mapping <- mapping\n    counts_dat_long$tool <- tool\n    counts_dat_long$desc <- desc\n    print(head(counts_dat_long))\n    con <- dbConnect(drv=MySQL(), user='talkLabAdmin', password ='_Talk0w_',dbname='TalkowskiGenomicsDB', host='mysql2.dipr.partners.org')\n    dbWriteTable(conn = con, name = \"geneRNASeq\",value = counts_dat_long,append=T, row.names=F)\n    dbDisconnect(con)\n}\n\n\n## PCA plot function\n## This function is used to plot a PC object selecting specific columns and a color variable\n\n\nmyPlotPC <- function(pr.obj,col1,col2, inCol=c(rep(\"red\",4),rep(\"blue\",4)))\n    {\n        plot(pr.obj$x[,col1]/pr.obj$sdev[col1],pr.obj$x[,col2]/pr.obj$sdev[col2],\n             pch=19, col=inCol,\n             xlab=paste(\"PC\",col1,sep=''),ylab=paste(\"PC\",col2,sep=''))\n        text(pr.obj$x[,col1]/pr.obj$sdev[col1],pr.obj$x[,col2]/pr.obj$sdev[col2],\n             labels=rownames(pr.obj$x),cex=0.7,\n             col=inCol, pos=1)\n    }\n\n\n## ********************************\n## This Section is RNASeq Specific\n\n## Create Manhattan plot setup\n\n## This function takes as input an ERCC genes list data in Long format and merges it with the ERCC\n## Concentrations etc for each ercc gene. Two important considerations are:\n##  1. input Data should have the gene identifier column with the geneID\n##  2. It also creates a merged Ercc concentration colum for downstream analysis\n\nmergedErccInfo<- function(inDat)\n    {\n        erccConcDat <- read.table(\"~/Documents/Research/CHGR/RNoteBooks/ERCCSpikeIn.txt\", header=T)\n        head(erccConcDat)\n        erccDat <- merge(inDat, erccConcDat, by.x=\"gene\", by.y=\"ERCCID\")\n        erccDat$concMix <- erccDat$concMix1\n        erccDat$concMix[which(erccDat$Mix == \"Mix2\")] <- erccDat$concMix2[which(erccDat$Mix == \"Mix2\")]\n        head(erccDat)\n        return(erccDat)\n    }\n\n",
    "created" : 1517847481119.000,
    "dirty" : false,
    "encoding" : "UTF-8",
    "folds" : "",
    "hash" : "1354858818",
    "id" : "D0AFEA9A",
    "lastKnownWriteTime" : 1507302713,
    "last_content_update" : 1507302713,
    "path" : "~/Documents/Rdata/EDA/R/generalfunctions.R",
    "project_path" : "R/generalfunctions.R",
    "properties" : {
    },
    "relative_order" : 8,
    "source_on_save" : false,
    "source_window" : "",
    "type" : "r_source"
}